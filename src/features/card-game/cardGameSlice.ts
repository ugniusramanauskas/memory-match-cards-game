import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { AppThunk, RootState } from '../../app/store';
import { ICard, CardId } from '../../services/types';

export interface CardGameState {
  cards: ICard[];
  cardIdsUnderEvaluation: CardId[];
  cardIdsMatched: CardId[];
}

const initialState: CardGameState = {
  cards: [],
  cardIdsUnderEvaluation: [],
  cardIdsMatched: [],
};

export const cardGameSlice = createSlice({
  name: 'cardGame',
  initialState,
  reducers: {
    addCardsToState: (state, action: PayloadAction<ICard[]>) => {
      state.cards = action.payload;
    },
    addCardIdToUnderEvaluation: (state, action: PayloadAction<CardId>) => {
      state.cardIdsUnderEvaluation.push(action.payload);
    },
    addCardIdToMatched: (state, action: PayloadAction<CardId>) => {
      state.cardIdsMatched.push(action.payload);
    },
    clearCardIdsUnderEvaluation: (state) => {
      console.log('clearing cardIdsUnderEvaluation');
      state.cardIdsUnderEvaluation = [];
    },
    // extraReducers: (builder) => {
    //   builder
    //     .addCase(clickCard.fulfilled, (state, action) => {
    //       state.status = 'idle';
    //       state.value += action.payload;
    //     })
    // },
    // clickCard: (state, action: PayloadAction<CardId>) => {
    //   console.log('clicked card: ', action.payload);
    //   if (!state.cardIdsUnderEvaluation.includes(action.payload)) {
    //     state.cardIdsUnderEvaluation.push(action.payload);
    //   }
    //   if (state.cardIdsUnderEvaluation.length === 2) {
    //     const [cardId1, cardId2] = state.cardIdsUnderEvaluation;
    //     const card1 = state.cards.find((card) => card.id === cardId1);
    //     const card2 = state.cards.find((card) => card.id === cardId2);
    //     if (card1 && card2 && card1.code === card2.code) {
    //       state.cardIdsMatched.push(cardId1, cardId2);
    //     }
    //     setTimeout(() => (state.cardIdsUnderEvaluation = []), 1000);
    //   }
    // },
  },
});

export const {
  addCardsToState,
  addCardIdToUnderEvaluation,
  addCardIdToMatched,
  clearCardIdsUnderEvaluation,
} = cardGameSlice.actions;

export const selectIsFlipped = (state: RootState, cardId: CardId) =>
  state.cardGame.cardIdsUnderEvaluation.includes(cardId) ||
  state.cardGame.cardIdsMatched.includes(cardId);

export const clickCard =
  (cardId: CardId): AppThunk =>
  (dispatch, getState) => {
    console.log('clicked card: ', cardId);
    const cardIdsUnderEvaluation = getState().cardGame.cardIdsUnderEvaluation;
    const cardIdsMatched = getState().cardGame.cardIdsMatched;
    if (
      !cardIdsUnderEvaluation.includes(cardId) &&
      !cardIdsMatched.includes(cardId) &&
      cardIdsUnderEvaluation.length < 2
    ) {
      dispatch(addCardIdToUnderEvaluation(cardId));
    }
  };

export default cardGameSlice.reducer;

// // We can also write thunks by hand, which may contain both sync and async logic.
// // Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd =
//   (amount: number): AppThunk =>
//   (dispatch, getState) => {
//     const currentValue = selectCount(getState());
//     if (currentValue % 2 === 1) {
//       dispatch(incrementByAmount(amount));
//     }
//   };

// Redux Toolkit allows us to write "mutating" logic in reducers. It
// doesn't actually mutate the state because it uses the Immer library,
// which detects changes to a "draft state" and produces a brand new
// immutable state based off those changes

// // The function below is called a thunk and allows us to perform async logic. It
// // can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// // will call the thunk with the `dispatch` function as the first argument. Async
// // code can then be executed and other actions can be dispatched. Thunks are
// // typically used to make async requests.
// export const incrementAsync = createAsyncThunk('cardGame/fetchCount', async (amount: number) => {
// //   const response = await fetchCount(amount);
//   // The value we return becomes the `fulfilled` action payload
// //   return response.data;
// });
// // The `extraReducers` field lets the slice handle actions defined elsewhere,
// // including actions generated by createAsyncThunk or in other slices.
// extraReducers: (builder) => {
//   builder
//     .addCase(incrementAsync.pending, (state) => {
//       state.status = 'loading';
//     })
//     .addCase(incrementAsync.fulfilled, (state, action) => {
//       state.status = 'idle';
//       state.value += action.payload;
//     })
//     .addCase(incrementAsync.rejected, (state) => {
//       state.status = 'failed';
//     });
// },
